<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="App design" href="../app-design/index.html" /><link rel="prev" title="Meta-capabilities" href="../behavioral-topics/topics/meta/index.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Protocol design - Practical Alloy</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #2a5adf;
  --color-brand-content: #2a5adf;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Practical Alloy</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Practical Alloy</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about-alloy/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about-book/index.html">About this book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../writer-notes.html">Writer notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structural-modeling/index.html">Structural modeling</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../structural-topics/index.html">Structural quick reads</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Structural quick reads</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/subset-signatures/index.html">Subset signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/nary-relations/index.html">Higher-arity relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/enumerations/index.html">Enumeration signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/commands/index.html">Commands in detail</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/themes/index.html">Visualization customization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/evaluator/index.html">The instance evaluator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/testing-instances/index.html">Encoding test instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/relational-logic/index.html">A relational logic primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/bestiary/index.html">Arrow multiplicity checks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/ordering/index.html">The predefined <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ordering</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/modules/index.html">Module system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/recursion/index.html">Handling recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/integers/index.html">Working with integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/type-system/index.html">Type system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/analysis/index.html">Structural analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../behavioral-modeling/index.html">Behavioral modeling</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../behavioral-topics/index.html">Behavioral quick reads</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Behavioral quick reads</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/mutable-toplevel-signatures/index.html">Mutable top-level signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/event-depiction/index.html">An idiom for event depiction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/scenarios/index.html">Encoding trace scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/evaluator/index.html">The trace evaluator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/temporal-logic/index.html">A temporal logic primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/pointwise-effects/index.html">Pointwise effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/fairness/index.html">Safety, Liveness and Fairness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/sequences/index.html">Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/macros/index.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/meta/index.html">Meta-capabilities</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Protocol design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app-design/index.html">App design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interaction-design/index.html">Interaction design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system-design/index.html">Controller design</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="protocol-design">
<span id="id1"></span><h1>Protocol design<a class="headerlink" href="#protocol-design" title="Link to this heading">#</a></h1>
<p id="index-0">In this chapter we will explain how to specify and analyze a
distributed protocol using Alloy. We will use a very simple example of
a leader election protocol. The aim of a leader election protocol is
to designate one node in a network as the <em>organizer</em> or <em>leader</em> of
some distributed task. Nodes are initially unaware of which node will
play that role, but after running the protocol all nodes should
recognize the same node as leader. Many different leader election
protocols exist: here we will use a well-known version that can be
used to elect a leader in a network of nodes organized in a ring, and
where nodes also have unique identifiers. This is an example commonly
used when presenting idioms for behavior specification in Alloy
<a class="reference internal" href="../../bibliography.html#mit12" id="id2"><span>[MIT12]</span></a>. This protocol was proposed by Chang and Roberts <a class="reference internal" href="../../bibliography.html#cacm79" id="id3"><span>[CACM79]</span></a>
and roughly operates as follows: the goal is to elect as leader the
node with the highest identifier; each node starts by sending its own
identifier clockwise; upon receiving an identifier, a node only
forwards it if it is higher than its own; a node receiving back its
own identifier designates itself as leader; finally the leader
broadcasts its newly found role to the network. In our specification
we will not model this last (trivial) step, and will only be concerned
with the fundamental property of a leader election protocol:
eventually exactly one (exactly one) node will designate itself as the
leader.</p>
<section id="specifying-the-network-configuration">
<h2>Specifying the network configuration<a class="headerlink" href="#specifying-the-network-configuration" title="Link to this heading">#</a></h2>
<p id="index-1">When designing a distributed protocol, we should start by specifying
the network configurations in which it is supposed to operate. In this
case, the protocol operates in a ring network of nodes with unique
identifiers. Notice that many different network configurations satisfy
this requirement: we could have rings of different size, and for the
same size, different assignments of the unique identifiers to the
nodes (the relevant fact here is the relative order in which the
identifiers appear in the network). The verification of the expected
properties of the protocol should take into account all possible
different configurations (up to the specified bound on the ring
size). The network configuration, although arbitrary, does not change
during the execution of the protocol. As such, it will be
specified with immutable sets and relations.</p>
<p>Unlike some formal specification languages, Alloy has no
pre-defined notion of <em>process</em> or <em>node</em>. These have to be explicitly
specified, by declaring a signature. Since the network of nodes forms
a ring, a binary relation that associates each node with its
immediate successor in the ring should also be declared.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-2">Recall that binary relations should be declared as fields inside the
domain signature. In the declaration of field <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">succ</span></code> the
multiplicity <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">one</span></code> is used to ensure that each node has exactly
one successor in the ring.  As usual in Alloy, we can immediately start
validating our specification by asking for example instances using a
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> command.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example</span> <span class="o">{}</span>
</pre></div>
</div>
<p>By iterating over the returned instances with <span class="guilabel">New</span> we could
get the following instance, which is not a valid ring.</p>
<a class="reference internal image-reference" href="../../_images/instance112.png"><img alt="../../_images/instance112.png" class="align-center" src="../../_images/instance112.png" style="width: 400px;" /></a>
<p>In addition to requiring each node to have exactly one successor, a simple way to ensure that a network forms a ring is to require that
every node is reachable from any other node. Given a node <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>,
to determine the set of nodes reachable from <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> via relation
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">succ</span></code> we can use expression
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.^</span><span class="n">succ</span></code>. This expression makes use of the composition (<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">.</span></code>) and transitive closure (<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">^</span></code>) operators presented in chapter <a class="reference internal" href="../structural-modeling/index.html#structural-modeling"><span class="std std-ref">Structural modeling</span></a>. The constraint that <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">succ</span></code> forms a ring can thus be specified in a fact as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">ring</span> <span class="o">{</span>
  <span class="c1">// succ forms a ring</span>
  <span class="k">all</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">succ</span>
<span class="o">}</span>
</pre></div>
</div>
<p>An alternative specification of fact <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ring</span></code> is to require that the set of all
nodes (denoted by <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>) is reachable from every node.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">ring</span> <span class="o">{</span>
  <span class="c1">// succ forms a ring</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">Node</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">succ</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we now iterate over all instances returned by command <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example</span></code> we will get the 3 possible rings with up to 3 nodes and a configuration without any node, which is also allowed by our specification. The limit of 3 is due to the implicit command scope of 3 atoms per top-level signature. As an example we show the ring with 3 nodes.</p>
<a class="reference internal image-reference" href="../../_images/instance24.png"><img alt="../../_images/instance24.png" class="align-center" src="../../_images/instance24.png" style="width: 400px;" /></a>
<p>To enforce that we have at least one node we can add the following fact.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">some_node</span> <span class="o">{</span>
  <span class="c1">// at least one node</span>
  <span class="k">some</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-3">Besides being organized in a ring, nodes must also have unique identifiers. Since we are going to need to compare identifiers, one possibility would be to just use integers to represent them. However, besides being totally ordered, integers carry additional semantics that is not necessary here. In particular, integers support arithmetic operations that will not be required in this example. When developing a formal specification it is good practice to be as abstract as possible and use the simplest structure that fulfills our needs. Also, the analysis of Alloy specifications with integers has some subtleties which makes it better to avoid, unless strictly necessary. As such, we will introduce a signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Id</span></code>, to denote identifiers, a binary relation <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code> that given an identifier will yield the next identifier in the total order, and two subset signatures to denote the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">first</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">last</span></code> identifiers of the order. All identifiers but one (the last) have a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code>, so the multiplicity of this relation should be <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">lone</span></code>. Signatures <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">first</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">last</span></code> have multiplicity <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">lone</span></code> instead of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">one</span></code> to allow for <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Id</span></code> to be empty.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Id</span> <span class="o">{</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Id</span>
<span class="o">}</span>
<span class="k">lone</span> <span class="kd">sig</span> <span class="nc">first</span><span class="p">,</span> <span class="nc">last</span> <span class="k">in</span> <span class="nc">Id</span> <span class="o">{}</span>
</pre></div>
</div>
<p id="index-4">To constrain <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code> to induce a total order over <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Id</span></code> we could, for example, require that <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">last</span></code> has no <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code> and all identifiers are reachable from <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">first</span></code>. The set of reachable identifiers (in zero or more steps via <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code>) can be determined with the (reflexive) transitive closure of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code>. This operator is defined as <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="o">^</span><span class="n">next</span> <span class="o">+</span> <span class="kc">iden</span></code>, the union of the transitive closure and the predefined identity binary relation, that relates each element of the domain to itself. We also need to enforce <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">first</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">last</span></code> to exist if there is some identifier.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">total_order</span> <span class="o">{</span>
  <span class="c1">// next induces a total order</span>
  <span class="k">some</span> <span class="n">Id</span> <span class="ow">implies</span> <span class="k">some</span> <span class="n">first</span> <span class="ow">and</span> <span class="k">some</span> <span class="n">last</span>
  <span class="k">no</span> <span class="n">last</span><span class="o">.</span><span class="n">next</span>
  <span class="n">Id</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.*</span><span class="n">next</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We can now define predicates to compare identifiers.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">lte</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.*</span><span class="n">next</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">gt</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="ow">not</span> <span class="n">lte</span><span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Having our identifiers totally ordered, we can now declare a field <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">id</span></code> inside signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>, to associate each node with its identifier.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">id</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Id</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-5">To ensure that identifiers are unique it suffices to require <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">id</span></code> to be injective, which can be done as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">unique_ids</span> <span class="o">{</span>
  <span class="c1">// ids are unique</span>
  <span class="k">all</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="k">lone</span> <span class="n">id</span><span class="o">.</span><span class="n">i</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we can now create a new <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> command to ask for all configurations with exactly 3 nodes and 3 identifiers, as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3</span> <span class="o">{}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Id</span>
</pre></div>
</div>
<p id="index-6">If we iterate over all instances with <span class="guilabel">New</span>, we will get the two only (truly) different configurations with this scope: one where the identifiers increase as we move clockwise in the ring, and another where they decrease. The former is depicted below. This illustrates the power of Alloy’s symmetry breaking, which in this case prevents the return of any other instance (that necessarily would be isomorphic to one of these two).</p>
<a class="reference internal image-reference" href="../../_images/instance33.png"><img alt="../../_images/instance33.png" class="align-center" src="../../_images/instance33.png" style="width: 400px;" /></a>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
The predefined <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ordering</span></code> module</div>
<p class="sd-card-text">Requiring that a signature is totally ordered is a very common requirement, and Alloy has a predefined module that can be used to impose a total order on a signature.</p>
</div>
<a class="sd-stretched-link reference internal" href="../structural-topics/topics/ordering/index.html#ordering"><span class="std std-ref"></span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Working with integers</div>
<p class="sd-card-text">Learn what are the caveats of using integers and how to properly address them in Alloy.</p>
</div>
<a class="sd-stretched-link reference internal" href="../structural-topics/topics/integers/index.html#integers"><span class="std std-ref"></span></a></div>
</div>
</section>
<section id="specifying-the-protocol-dynamics">
<span id="specifying-protocol-dynamics"></span><h2>Specifying the protocol dynamics<a class="headerlink" href="#specifying-the-protocol-dynamics" title="Link to this heading">#</a></h2>
<p id="index-7">The coordination between the different nodes in this distributed protocol, like in many others, is achieved by means of message passing. Like nodes, Alloy has no special support for message passing, so all the relevant concepts have to be specified from scratch. In this case messages are just node identifiers, so there is no need to add a signature to model those. To capture the incoming and outgoing messages we can declare mutable binary fields inside signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>, to associate each node with the set of identifiers it has received or that need to be sent, respectively. Using sets for the mailboxes is an abstraction that allows us to verify that the protocol is correct even if messages are transmitted out of order. In this protocol the same message is never sent twice by each node, so we also don’t need to account for multiple copies of the same message.
To declare a mutable field the keyword <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">var</span></code> should be used.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">id</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Id</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Id</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">outbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Id</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We also need to capture the nodes that have been elected as leaders. To do so we can declare a mutable signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> that is a subset of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="kd">sig</span> <span class="nc">Elected</span> <span class="k">in</span> <span class="nc">Node</span> <span class="o">{}</span>
</pre></div>
</div>
<p>If we now run the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> command we might get the following instance.</p>
<a class="reference internal image-reference" href="../../_images/instance62.png"><img alt="../../_images/instance62.png" class="align-center" src="../../_images/instance62.png" style="width: 700px;" /></a>
<p id="index-8">As we have seen in the <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a> chapter, the interface of the visualizer is different when we have mutable elements: it now shows two states of a trace side-by-side, there are several new instance exploration buttons in the toolbar, and a depiction of a path just below those. In this case we have a trace where the same state 0 repeats itself indefinitely, something that is possible since so far we added no restrictions that constrain the behavior of the protocol. We recall that in the depiction of the states, by default, immutable sets and fields (the configuration of the protocol) are shown with solid lines, while mutable ones are shown with dashed lines.</p>
<p id="index-9">To simplify the visualization, we can configure the theme so that node identifiers, the inbox, and the outbox are shown as node attributes, and change the color of elected nodes to green. Since the elected nodes can now be easily distinguished by color we can also hide the respective textual label. As for the totally ordered identifiers, we will just show the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">next</span></code> relation. The result of this customization will be the following.</p>
<a class="reference internal image-reference" href="../../_images/instance72.png"><img alt="../../_images/instance72.png" class="align-center" src="../../_images/instance72.png" style="width: 600px;" /></a>
<p id="index-10">Something that is clearly wrong in our instance is that in the initial
state nodes already have identifiers in their inboxes and outboxes, and some of them are already elected. To restrict the initial value of these mutable fields we can add the following fact.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">init</span> <span class="o">{</span>
  <span class="c1">// initially inbox and outbox are empty</span>
  <span class="k">no</span> <span class="n">inbox</span> <span class="ow">and</span> <span class="k">no</span> <span class="n">outbox</span>
  <span class="c1">// initially there are no elected nodes</span>
  <span class="k">no</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Since these constraints have no temporal operators (more on those later)
it applies to the initial state of the system. Rerunning the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> command now yields instances such as the following, where the
systems remains indefinitely in a valid initial state.</p>
<a class="reference internal image-reference" href="../../_images/instance82.png"><img alt="../../_images/instance82.png" class="align-center" src="../../_images/instance82.png" style="width: 600px;" /></a>
<p id="index-11">We can explore additional instances by using the instance exploration buttons in the toolbar. For example, the <span class="guilabel">New Fork</span> button asks the Analyzer for a different trace with the same behavior up to the left-hand side state, but a different outcome of the current transition (a different right-hand side state). By pressing this button we may get the following.</p>
<a class="reference internal image-reference" href="../../_images/instance92.png"><img alt="../../_images/instance92.png" class="align-center" src="../../_images/instance92.png" style="width: 600px;" /></a>
<p>This trace displays a behavior that should not be allowed in a correct execution of the protocol: in the second state all of a sudden several identifiers appeared in the inbox and outbox of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code>. Moreover this node was also randomly designated as leader. So far this is allowed because we added no constraints to our specification that restrict how the system can transition from one state to another. If there are no constraints then any transition is possible.</p>
<p id="index-12">As already explained in chapter <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a>, the simplest way to constrain the valid transitions is to consider all the possible events that can occur in the system, and for each event specify when it can occur (its <em>guard</em>) and what is its <em>effect</em> on the mutable relations. In our protocol we can distinguish three possible events:</p>
<ul class="simple">
<li><p>a node <em>initiates</em> the execution by sending its own identifier to the next node;</p></li>
<li><p>a node reads and <em>processes</em> an identifier in its inbox, decides whether it should be propagated or discarded and, if it is its own identifier, elects itself as leader;</p></li>
<li><p>the network <em>sends</em> one message in the outbox of a node to the next one.</p></li>
</ul>
<p>Alloy has no special keywords to declare events. A common
approach is to declare a predicate for each event, that
specifies its guard and effect, and add a
constraint enforcing that at each possible state only one of those
predicates can hold. Event predicates can also be parametrized, which in our example will be the node where the event occurs.</p>
<p id="index-13">Let’s begin by specifying the <em>initiate</em> event. For each event we should
always start by specifying what is its guard, a constraint on the
current (or pre-) state that determines when can the event occur. To simplify our
specification, for the moment, we will assume that a node is free to initiate (or
re-initiate) the protocol whenever it wants, so in this case there will
be no guard, meaning the event is always possible. Then we should
specify the effect of the event on all mutable relations of the specification:
note that if nothing is said about a particular mutable relation then
its value can change freely when the event occurs. A special effect is
forcing the value of a mutable relation to not change at all,
something known as a <em>frame condition</em>. For example in this event we
will have two frame conditions, since it does not change the value of
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> nor <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>. To specify that a relation does not
change with a logic formula we need to refer to its value in the next
(or post-) state. In Alloy the value of a relation (or relational
expression) in the next state is accessed by appending a prime. So, to
state that, for example, the relation <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> does not change we
could add the constraint <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span></code>. Likewise for
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>. So far, the specification of event initiate looks as
follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_no_effect</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="n">inbox</span><span class="o">&#39;</span>   <span class="o">=</span> <span class="n">inbox</span>                           <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We now need to specify the effect on relation <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code>. We can
start by specifying its effect on the outbox of the initiating
node. Expression <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> denotes the set of identifiers in
the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of node <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> in the current state. The effect
of this event on this set is to add <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>’s own identifier, which
can be specified by <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span></code>. Here we used
the set union operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">+</span></code> to add the singleton set <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>
to <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code>. Note that requiring <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code> to be present in
the outbox in the next state, which could be specified by <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span>
<span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span></code>, is not sufficient, as it would allow identifiers other than <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>
to be freely removed or added from <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code>. Having specified
the effect on the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> we now need to specify the
effect on the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of all other nodes. Again, if nothing is
said about those, they will be allowed to vary freely. Of course this
event should not modify the outboxes of other nodes, something we
could specify with constraint <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span>
<span class="n">m</span><span class="o">.</span><span class="n">outbox</span></code>, that quantifies over all nodes except the initiating one. The final specification of our event looks as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_no_guard</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>                <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">inbox</span><span class="o">&#39;</span>   <span class="o">=</span> <span class="n">inbox</span>                           <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-14">To validate our first event we can impose a restriction stating that,
for the moment, this is the only event that can occur, and inspect the
possible instances to see if the system behaves as expected. To
specify such a restriction we need the temporal logic operator
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span></code> to enforce a formula to be true at all
possible states. In particular, to enforce that, at every possible
state, one of the nodes initiates the protocol, the following
fact can be added to the specification.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">always_initiate</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate_no_guard</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Running command <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> yields the following trace, where
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node2</span></code> initiates the protocol and then nothing else happens.</p>
<a class="reference internal image-reference" href="../../_images/instance101.png"><img alt="../../_images/instance101.png" class="align-center" src="../../_images/instance101.png" style="width: 600px;" /></a>
<p id="index-15">On first glance, this may seem like an invalid trace, given that we
required that at every state one node initiates the protocol. However,
if we look closely at our specification of event <em>initiate</em> we
can see that it also holds true in a state where a node already has
its own identifier in the outbox, which
will remain in the outbox. Our specification did not had a guard forbidding
this occurrence of the event, and the effect <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span>
<span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span></code> is also true if <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code> is already in
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> and in <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span></code>.</p>
<p>To address this issue we could add a guard like <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> to predicate <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">initiate_no_guard</span></code>.  However, this
only forbids a node from initiating the protocol if it’s own
identifier is in its outbox at that particular moment. This means that, once we
include an event to send messages and this identifier leaves the
outbox, a node will be able to re-initiate the protocol. This does not
pose any problem concerning the correctness of this particular
protocol, but if we really wanted each node to initiate the protocol
only once we would need to strengthen this guard.</p>
<p>One possibility would be to add a field to record at which phase of
the protocol execution each node is in, and allow this event only when
a node is in an “uninitiated” phase. This would be the common approach
in most formal specification languages. However, with Alloy we have a
more direct alternative. Since there is no special language to specify
events and they are specified by arbitrary logic formulas, we are free
to use temporal operators to specify guards or effects. By contrast,
in most formal specification languages we can only specify the
relation between the pre- and post-state.</p>
<p id="index-16">In this case we could, for example, use the temporal operator
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">historically</span></code>, that checks if something was always true in the
past up to the current state, to only allow <em>initiate</em> to occur
if the node’s identifier was never in its outbox. The specification of
our event would look as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>                <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">inbox</span><span class="o">&#39;</span>   <span class="o">=</span> <span class="n">inbox</span>                           <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Unfortunately, after adding this guard our command will
return no trace, meaning there are no behaviors that satisfy our
constraints. This happens because we are currently not
allowing messages to be sent or read, so after all nodes have
initiated the protocol nothing else is allowed to happen by our
specification, and it is impossible to obtain a valid trace. Recall
that traces are infinite sequences of states, where the system is
always evolving. A simple way to solve this issue is to add an event
allowing the system to <em>stutter</em>, that is to do nothing (keeping the
value of all relations unchanged). Stuttering can also be understood as
an event specifying something else that is occurring on the environment
outside the scope of our specification, and in general it is a good
idea to add such stuttering events. In this case, a
predicate to specify a stuttering event can be specified as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">stutter</span> <span class="o">{</span>
  <span class="n">outbox</span><span class="o">&#39;</span>  <span class="o">=</span> <span class="n">outbox</span>
  <span class="n">inbox</span><span class="o">&#39;</span>   <span class="o">=</span> <span class="n">inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To allow this event we need to change the above fact that restricts
the possible behaviours.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">stutter_or_initiate</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="n">stutter</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-17">Running command <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> returns a trace where nothing happens
in our system, something that is now allowed. If we press
<span class="guilabel">New Fork</span> we might get a trace such as the previously
depicted, where <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node2</span></code> initiates the protocol and then nothing
else happens. If we move to the next state by pressing <span class="guilabel">→</span>,
and fork again with <span class="guilabel">New Fork</span>, we might get the following
trace where <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node0</span></code> initiates the protocol after <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node2</span></code>.</p>
<a class="reference internal image-reference" href="../../_images/instance113.png"><img alt="../../_images/instance113.png" class="align-center" src="../../_images/instance113.png" style="width: 600px;" /></a>
<p>By exploring a bit more the possible traces we can get some confidence
that event <em>initiate</em> is well specified.</p>
<p>Let us now specify the <em>send</em> event. In this event we could have as parameters the node
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> from where the message will be sent and the message
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> that will be sent (an identifier). The guard of this event
should require <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> to be in the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>. The
effect will be to remove <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> from the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>, and add it to the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> of the next node <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code>. All
other inboxes and outboxes should keep their value, as well as the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> set. The specification of this event would be the following.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">send</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is sent from node n to its successor</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>                              <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">-</span> <span class="n">i</span>                   <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span>           <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-18">For event <em>process</em> again we could have as parameters the node
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> and the message <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> to be
read and processed. The guard should require that <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> is in the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>. The effect on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> is obvious:
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> should be removed from the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> and
all other inboxes should keep their value. The effect on the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> depends on the whether <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> is
greater than <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>: if so, <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> should be added to the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code>, to be later propagated along the ring; if not, it
should not be propagated, meaning the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> will
keep its value.  To write such conditional outcome we could use the
logical operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">implies</span></code> together with an <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">else</span></code>:
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">C</span> <span class="ow">implies</span> <span class="n">A</span> <span class="k">else</span> <span class="n">B</span></code> is the same as <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">(</span><span class="n">C</span> <span class="ow">and</span> <span class="n">A</span><span class="o">)</span> <span class="ow">or</span> <span class="o">(</span><span class="ow">not</span> <span class="n">C</span>
<span class="ow">and</span> <span class="n">B</span><span class="o">)</span></code>, but the former is easier to understand.  The event has no
effect on the outboxes of other nodes, which should all keep their
value. The same conditional outcome applies to <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>: if the
received <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> is equal to the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>’s own identifier, then
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> should be included in <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>; else <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>
keeps its value. The full specification of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">process</span></code> is as
follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                      <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>       <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.outbox</span>
             <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>     <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">implies</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span> <span class="o">+</span> <span class="n">n</span>     <span class="c1">// effect on Elected</span>
           <span class="k">else</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>We should now add these two events to the fact that constraints the
valid behaviours of our system.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">events</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span>
    <span class="n">stutter</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">send</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">read</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-19">Before proceeding to the verification of the expected properties of
the protocol, we should play around with the different instance
exploration buttons to explore different execution scenarios and
validate the specification of our events. An alternative would be to
ask for specific scenarios directly in a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> command. For
example, we could change command <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example</span></code> to ask directly for a
scenario where some node will be elected. To do so we need to use the
temporal operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">eventually</span></code>, which checks if a formula is
valid at some point in the future (including the present state). Our
command would look as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">eventually_elected</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Id</span>
</pre></div>
</div>
<p>Running this command will return a trace with 8 states where the
highest identifier is passed around until the respective node gets
elected. This is the shortest trace where a leader can be elected in a
ring with 3 nodes, corresponding to one initiate event followed by 3
interleaved send and read events. The Analyzer guarantees that the
shortest traces that satisfy (or refute) a property are returned
first. The first transition of this trace is the following, where the
node with the highest identifier (beware, that this is <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Id1</span></code>) initiates the protocol.</p>
<a class="reference internal image-reference" href="../../_images/instance121.png"><img alt="../../_images/instance121.png" class="align-center" src="../../_images/instance121.png" style="width: 600px;" /></a>
<p>In the last transition, that can be focused by pressing <span class="guilabel">→</span>
6 times or by directly clicking the state numbered 6 in the trace
depiction, this node reads back its own
identifier that was passed around in the ring and elects himself as
leader.</p>
<a class="reference internal image-reference" href="../../_images/instance131.png"><img alt="../../_images/instance131.png" class="align-center" src="../../_images/instance131.png" style="width: 600px;" /></a>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Frame conditions</div>
<p class="sd-card-text">Learn about the different ways to specify effects and frame conditions of events. Some of them allow for a very terse style that simplifies the specifications.</p>
</div>
<span class="sd-stretched-link"></span></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Encoding scenarios</div>
<p class="sd-card-text">Learn how to specify richer <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> commands to search for specific scenarios, where a particular sequence of events occurred.</p>
</div>
<a class="sd-stretched-link reference internal" href="../behavioral-topics/topics/scenarios/index.html#scenarios"><span class="std std-ref"></span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Event depiction</div>
<p class="sd-card-text">Learn a simple Alloy idiom that can be used to depict which events occurred in each transition of a trace.</p>
</div>
<a class="sd-stretched-link reference internal" href="../behavioral-topics/topics/event-depiction/index.html#event-depiction"><span class="std std-ref"></span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
A temporal logic primer</div>
<p class="sd-card-text">Read about the full syntax and semantics of the temporal logic supported in Alloy.</p>
</div>
<a class="sd-stretched-link reference internal" href="../behavioral-topics/topics/temporal-logic/index.html#temporal-logic"><span class="std std-ref"></span></a></div>
</div>
</section>
<section id="verifying-the-expected-properties-of-the-protocol">
<h2>Verifying the expected properties of the protocol<a class="headerlink" href="#verifying-the-expected-properties-of-the-protocol" title="Link to this heading">#</a></h2>
<p>The key property of our protocol is that exactly one node
will become leader. We can break this property into to simpler ones:</p>
<ul class="simple">
<li><p>there will never be more than one leader;</p></li>
<li><p>every leader remains leader;</p></li>
<li><p>eventually there will be at least one leader.</p></li>
</ul>
<p id="index-20">These properties are of very different nature: the first two are a
<em>safety</em> properties, forbidding some (undesired) behavior of the system,
while the latter is a <em>liveness</em> property, forcing some (desirable)
behavior of the system. The analysis of safety properties is usually
simpler than the analysis of liveness properties. To find a
counter-example for a safety property it suffices to search for a
finite sequence of states that leads to a (bad) state (in the case
of the first property, one state where there are two or more leaders), and it is irrelevant what
happens afterwards, as any continuation of this finite sequence will
still be a counter-example. On the other hand, to find a
counter-example for a liveness property it is necessary to search for
a complete infinite trace where the expected behavior definitely never
happened (in the case of the last property, one trace where a leader is never elected). Moreover, it will
be necessary to impose additional <em>fairness</em> conditions when verifying
liveness properties, in particular to forbid bogus counter-examples
where at some point the system stutters forever and never executes an enabled event.</p>
<p id="index-21">Let us start by verifying the first (safety) property. Recall that
properties that are expected to hold can be written in named
assertions (declared with keyword <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">assert</span></code>) and then verified
with <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">check</span></code> commands. This safety property is a very simple
example of an <em>invariant</em>, a property that requires something to be
be true in all states of all possible traces. In Alloy, invariants can
be specified using the temporal operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span></code>. In each state, to check that
there is at most one leader in set <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> we could use
the keyword <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">lone</span></code>. This invariant could thus
be specified as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_most_one_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">lone</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To check this assertion we could define the following command.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span>
</pre></div>
</div>
<p id="index-22">This protocol is known to be correct, so, as expected, running this
command returns no counter-example. Recall that the default scope on
top-level signatures is 3, so this command verifies a single
execution that the property holds for all rings with up to three
nodes. This Alloy ability of model checking a property at once for all possible configurations of a system is not possible in some competing model checkers, where we are forced to specify the specific configuration on which we want to verify a protocol. That is rather cumbersome, since with a reasonable scope there can be many different configurations and its difficult to even enumerate them manually. Also, we could easily miss a bug in a specific configuration.</p>
<p>As mentioned in chapter <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a>, by default, verification of temporal properties in Alloy is
done with a technique known as <em>bounded model checking</em>, meaning that
the search for counter-examples will only consider a given maximum
number of different transitions before the system starts
exhibiting a repeated behavior. By default this maximum number
is 10. To increase our confidence in the result of the analysis we
could, for example, check this property for all rings with up to 4
nodes and consider up to 20 different transitions (or steps). To do so
we could change the scope of the command as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="mi">4</span> <span class="k">but</span> <span class="mi">20</span> <span class="k">steps</span>
</pre></div>
</div>
<p>This commands sets the default scope on signatures to 4 but also
changes the scope on transitions to 20 using keyword
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">steps</span></code>. Again, as expected, no counter-example is returned, but
the analysis now takes considerably longer, as there are many more
network configurations and states to explore.</p>
<p id="index-23">It is also possible to check a temporal property with <em>unbounded model
checking</em> if a compatible solver is selected. This will consider an arbitrary number of
transitions, but still with the signatures bounded by a maximum
scope. To do so, a special scope on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">steps</span></code> is needed
to trigger unbounded temporal analysis.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="mi">4</span> <span class="k">but</span> <span class="mi">1</span><span class="o">..</span> <span class="k">steps</span>
</pre></div>
</div>
<p id="index-24">The second expected property is another example of a safety property, this time requiring a nested <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span></code> operator to be specified.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">leader_stays_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Elected</span> <span class="o">|</span> <span class="ow">always</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">leader_stays_leader</span>
</pre></div>
</div>
<p>The third expected property is a very simple example of a liveness
requirement, namely one that requires something to hold at least in
one state of every trace. Such properties can be specified directly
with the temporal operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">eventually</span></code>. Inside this temporal
operator, again a very simple cardinality check on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>
suffices, this time with keyword <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">some</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_least_one_leader</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="o">(</span><span class="k">some</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-25">The following command can be used to check this property with bounded model
checking and the default scopes.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_least_one_leader</span>
</pre></div>
</div>
<p>We recommend that you start by
verifying specifications with bounded model checking, because it is
usually much faster than the unbounded counterpart, and most
counter-examples tend to require only a handful of transitions. Once
you have a design where no counter-example is returned with bounded
model checking, you can increase your confidence on the analysis by using
unbounded model checking. As hinted above, running this command immediately returns a
counter-example where the system stutters forever, and obviously no
leader is elected. This conter-example can be replicated in trivial configurations, for example the following with a single node.</p>
<a class="reference internal image-reference" href="../../_images/instance141.png"><img alt="../../_images/instance141.png" class="align-center" src="../../_images/instance141.png" style="width: 600px;" /></a>
<p id="index-26">This behavior is currently allowed because we added a stutter event that
captures events external to our system. At the moment this event can
occur indefinitely, which is a bit unrealistic or <em>unfair</em> to the
system under analysis: for example, if at some point one node is
continuously ready to execute one its events (the node is continuously
<em>enabled</em>), then it should eventually do something. For example, in our
protocol, a trace where at some point a message is in the inbox of a
node but is never read is unfair to that node.</p>
<p>To specify such fairness properties we first need to understand two
well-known combinations of the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">eventually</span></code>
temporal operators:</p>
<ul class="simple">
<li><p><code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">eventually</span> <span class="ow">always</span> <span class="n">p</span></code> holds in a system if all traces reach a state where <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">p</span></code> becomes valid indefinitely.</p></li>
<li><p><code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span> <span class="ow">eventually</span> <span class="n">p</span></code> holds in a system if in every state of every trace <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">p</span></code> is later valid, which means that <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">p</span></code> is true infinitely often.</p></li>
</ul>
<p>To specify that a node is at some point continuously enabled we can use the
first combination. Most of the times the enabled condition for a node is exactly
the same as the disjunction of the guards of its events. In our case a node
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> is enabled if it has never initiated or has some message in the inbox
or in the outbox. To specify that a continuously enabled event eventually occurs
(after the point it becomes enabled) the second combination of operators
presented above can be used. Note that a continuously enabled event would still
be (continuously) enabled after the required occurrence of the event, which
means that the event should occur again and again, or infinitely often. So, the
desired fairness condition can be specified as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">fairness</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="ow">eventually</span> <span class="ow">always</span> <span class="o">(</span><span class="ow">historically</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">)</span>
    <span class="ow">implies</span>
    <span class="ow">always</span> <span class="ow">eventually</span> <span class="o">(</span><span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">|</span> <span class="n">process</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">]</span> <span class="ow">or</span> <span class="n">send</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-27">Technically, this fairness condition is known as <em>weak fairness</em>, as
the event is only required to happen if continuously enabled. Often
this suffices to verify most liveness properties. However, sometimes
we may need <em>strong fairness</em> constraints, requiring that the event
occurs when it becomes recurrently enabled (infinitely often, but
not necessarily continuously).</p>
<p>If we change the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">AtLeastOneLeader</span></code> assertion to assume
the above fairness condition, no counter-example will be returned even with increased
scopes, as expected.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_least_one_leader_fair</span> <span class="o">{</span>
  <span class="n">fairness</span> <span class="ow">implies</span> <span class="ow">eventually</span> <span class="o">(</span><span class="k">some</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">check</span> <span class="n">at_least_one_leader_fair</span>
</pre></div>
</div>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Fairness and Liveness</div>
<p class="sd-card-text">Learn how to specify different fairness conditions and the impact they have on the analysis.</p>
</div>
<a class="sd-stretched-link reference internal" href="../behavioral-topics/topics/fairness/index.html#fairness"><span class="std std-ref"></span></a></div>
</div>
</section>
<section id="making-the-specification-more-abstract">
<h2>Making the specification more abstract<a class="headerlink" href="#making-the-specification-more-abstract" title="Link to this heading">#</a></h2>
<p>There are several ways in which we can make our specification of this protocol more abstract, and potentially speed up its analysis. For example, we actually do not need to model the identifiers explicitly: we can use each node atom name as its own identifier. For this we should impose the total order on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code> itself, and get rid of signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Id</span></code> and field <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">id</span></code>. Since we have a fact requiring that at least one node exists, the total order specification can even be a bit simpler.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">outbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span>
<span class="o">}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">first</span><span class="p">,</span><span class="nc">last</span> <span class="k">in</span> <span class="nc">Node</span> <span class="o">{}</span>

<span class="k">fact</span> <span class="nf">total_order</span> <span class="o">{</span>
  <span class="c1">// next induces a total order</span>
  <span class="k">no</span> <span class="n">last</span><span class="o">.</span><span class="n">next</span>
  <span class="n">Node</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.*</span><span class="n">next</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Of course, now we have to slightly change the specification of our event predicates and the assertions. For example, event <em>process</em> can now be specified as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                      <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>       <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span>    <span class="c1">// effect on n.outbox</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>     <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span> <span class="o">+</span> <span class="n">n</span>        <span class="c1">// effect on Elected</span>
        <span class="k">else</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> command now only needs to specify a scope for <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span>
</pre></div>
</div>
<p>Running this command yields the following instance (with the theme already customized), and it is now more clear if the ring follows the increasing order of the identifiers (as happens here), or the other way around.</p>
<a class="reference internal image-reference" href="../../_images/instance151.png"><img alt="../../_images/instance151.png" class="align-center" src="../../_images/instance151.png" style="width: 600px;" /></a>
<p id="index-28">Another signature we can remove is <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>, since actually we can infer which node has been elected by looking at what happened in the past: if at some point in the past a node had its identifier in the inbox and processed it, then it necessarily became a leader. Instead of declaring a subset signature we can define <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> as a derived set of nodes using a function without parameters.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here, the set of elected nodes at each state is defined by comprehension. Note
the usage of the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">once</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">before</span></code> past operators to check if
the desired transition happened in the past. We can now simplify the
specification of all three events, removing the effects on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code>. For
example, event <em>process</em> can now be specified as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                      <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>       <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span>    <span class="c1">// effect on n.outbox</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>     <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Another abstraction could be to remove the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">outbox</span></code> and incorporate the sending of a message in the <em>initiate</em> and <em>process</em> events. This is a reasonable simplification in this protocol, since each node only communicate with the successor node, and out of order message delivery is already being modeled by having the inboxes contain sets of messages. The declaration of signature <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code> becomes the following.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The specification of event <em>initiate</em> should be changed to directly add the node identifier to the inbox of the successor node.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span>            <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>  <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, the specification of <em>process</em> should also be changed accordingly.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                     <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                           <span class="c1">// effect on n.inbox</span>
  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.succ.inbox</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we now run the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example3</span></code> command we can see that it is now possible
to elect a leader in a ring with three nodes with almost half the transitions
(since send events are removed).</p>
<a class="reference internal image-reference" href="../../_images/instance161.png"><img alt="../../_images/instance161.png" class="align-center" src="../../_images/instance161.png" style="width: 600px;" /></a>
<p>With the same scope on the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">steps</span></code> we can now check much longer behaviors
with roughly the same efficiency. If we check our three assertions they are all
still valid, as expected.</p>
<p>However, this specification is actually not correct! If we run the following
command to get an example of electing a leader in a ring with one node, we will
get no instances.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example1</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">1</span> <span class="n">Node</span>
</pre></div>
</div>
<p>The problem is in the specification of the effect of <em>process</em> on
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code>. If the ring has a single node, both <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> and
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> are the same node, and the two conditions specifying the effect
on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code> and on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">inbox</span></code> contradict themselves, so the
<em>process</em> event cannot actually occur (is not truly enabled) even if its guard
is true in a state. This was the reason why checking the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">AtLeastOneLeader</span></code> assertion did not produce a counter-example, because
the fairness condition has the wrong enabledeness condition for this event. It
is very easy to commit such subtle mistakes while specifying, and introduce
inconsistencies, and to avoid them we should always exhaustively validate our
specification before checking our assertions. Ideally, we should have different
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> commands to check the consistency of different scenarios, for
example asking to examples where leaders are elected in rings of different
sizes. To fix the specification of <em>process</em> we could require the frame
condition on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code> to only apply when <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> is not <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>
itself.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                     <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                           <span class="c1">// effect on n.inbox</span>
  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.succ.inbox</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we ask for a trace where a leader is elected in a ring with one node, we get the expected outcome after two events.</p>
<a class="reference internal image-reference" href="../../_images/instance171.png"><img alt="../../_images/instance171.png" class="align-center" src="../../_images/instance171.png" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../../_images/instance181.png"><img alt="../../_images/instance181.png" class="align-center" src="../../_images/instance181.png" style="width: 600px;" /></a>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-link" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Encoding scenarios</div>
<p class="sd-card-text">Learn how to specify richer <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> commands to search for specific scenarios, where a particular sequence of events occurred.</p>
</div>
<a class="sd-stretched-link reference internal" href="../behavioral-topics/topics/scenarios/index.html#scenarios"><span class="std std-ref"></span></a></div>
</div>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>&#64;nuno: we never mentioned the relational style of effects here, which is actually quite nice</p>
</div>
</section>
<section id="explicit-message-passing">
<h2>Explicit message-passing<a class="headerlink" href="#explicit-message-passing" title="Link to this heading">#</a></h2>
<p>Up until now, we’ve actually been addressing only a phase of the leader election
protocol. In a second phase, once a node identifies itself as the leader, it
should propagate that information through all the other nodes to make sure that
every node is aware of the elected leader. This second phase can begin while
there are still messages from the first phase being exchanged, but in essence
they contain the same information: an identifier, either of a candidate or of
the leader. Thus, we can no longer abstract messages by just exchanging
identifiers between nodes, and must introduce richer messages into our model.
The need for such data structures is typical in software design, and in a
programming language we would probably encode these messages as a <em>record</em>, or
<em>struct</em>. However, doing so in Alloy has some caveats that must be taken into
consideration. This section explores the pros and cons of some possible
strategies to encode such messages.</p>
<section id="messages-as-static-signatures">
<h3>Messages as static signatures<a class="headerlink" href="#messages-as-static-signatures" title="Link to this heading">#</a></h3>
<p>We can easily extend our model to support messages by introducing an abstract
static signature to represent them, and then extend it by the more specific
message types. Signature fields would represent the data fields of the messages.
In our leader election protocol, we have two message types that happen to
contain the same kind of data – a node identifier – so we can define that
field at the top-level signature, which will be inherited by the specific
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ElectedMsg</span></code>. The message content is mandatory, so it is
assigned multiplicity <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">one</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="n">payload</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>

<span class="kd">sig</span> <span class="nc">CandidateMsg</span><span class="p">,</span> <span class="nc">ElectedMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{}</span>
</pre></div>
</div>
<p>Then we need to adapt the node’s inboxes and outboxes to contain such messages.
In the current state of our leader election model, where we have abstracted away
the outboxes, this could simply be done as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Message</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Next, we must adapt the event predicates to consider messages. Some of these
events (such as when a node initiates, or elects itself the leader) are expected
to ‘create’ new messages. This is a main difference between record-like data
structures and trying to model them as static signatures: messages are never
really created, they permanently belong to a fixed universe of available
messages determined by the scope. Predicates must instead search for a messages
with the required content in that universe of messages through an existential
quantification. Predicate <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">initiate</span></code>, for instance, could be adapted in the
following way.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="k">no</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// guard</span>

  <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">{</span>
    <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m</span>                      <span class="c1">// effect on n.succ.inbox</span>
    <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>            <span class="c1">// effect on the outboxes of other nodes</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The first difference is in the guard: rather than testing whether its own
identifier has ever been in the inbox, an initializing nodes checks for a
candidate message with its identifier. Note that for a node identifier <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>,
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">payload</span><span class="o">.</span><span class="n">n</span></code> retrieves all messages with that identifier, which intersected with
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> gives all candidate messages for node <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> (in the current model,
there may multiple <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> atoms with the same payload). The second
difference is the existential quantification that searches for a message of the
appropriate type and content, and adds it to the successor’s inbox.</p>
<p>Rather than having an identifier as a parameter, the <em>process</em> event should now
consider a message. To ease the specification, we split the <em>process</em> event into
two predicates: processing a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> message or processing an
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ElectedMsg</span></code> message. Predicate <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">processCandidate</span></code> becomes slightly more
complicated, since there are now three possible effects on the successor’s
inbox: as previously, it may either discard the message (if the identifier in
the message is smaller than that of the node), propagate it (if the identifier
in the message is larger than the one of the node). But now, when a node elects
itself as the leader (the identifier in the message is the same as that of the
node), it must also send a new elected message informing other nodes of that
fact. One possibility is to encode it as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processCandidate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// m is read and processed by node n</span>

  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                              <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">m</span>                                    <span class="c1">// effect on n.inbox</span>
  <span class="n">gt</span><span class="o">[</span><span class="n">m</span><span class="o">.</span><span class="n">payload</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m</span>  <span class="c1">// effect on n.succ.inbox</span>
                  <span class="k">else</span>    <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span>
                      <span class="o">(</span><span class="k">some</span> <span class="n">m2</span> <span class="p">:</span> <span class="n">ElectedMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">|</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m2</span><span class="o">)</span>
                  <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">n2</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span>         <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To avoid complications identified earlier for rings with a single node, we
simply do not create the elected message in those cases (i.e., when the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> is
its own successor). Otherwise, an elected message with the appropriate node
identifier is selected from the universe and added to the successor’s inbox.</p>
<p>Predicate <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">processElected</span></code> is very simple, just propagating the elected messages
unless it’s the elected leader receiving the message again after going through
the ring, in which case it is discarded.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processElected</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// m is read and processed by node n</span>

  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                             <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">m</span>                                   <span class="c1">// effect on n.inbox</span>
  <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m</span>  <span class="c1">// effect on n.succ.inbox</span>
                 <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>

  <span class="k">all</span> <span class="n">n2</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span>        <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You might have noticed that both <em>process</em> predicates share the guard and some
effects. To promote maintainability, one could factor out the common formulas to
an auxiliary predicate, simulating a kind of event hierarchy. That predicate
would then be called from the concrete events as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processMessage</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Message</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// m is read by node n</span>

  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                      <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span>                             <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">n2</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">processCandidate</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">processMessage</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">]</span>

  <span class="o">...</span> <span class="c1">// effect on n.succ.inbox</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">processElected</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">processMessage</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">]</span>

  <span class="o">...</span> <span class="c1">// effect on n.succ.inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> function, which determines the nodes considered elected at each
state, must also be adapted to consider messages. Again, recall that there may
be more than a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> with the same node identifier, so we must test
whether the inbox of a node has ever contained one of those messages, which may
be achieved by testing whether their intersection is empty. To promote
readability, we use a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">let</span></code>-expression to reuse that expression.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span>
    <span class="k">let</span> <span class="n">inbox_candidates</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">|</span>
      <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="k">some</span> <span class="n">inbox_candidates</span> <span class="ow">and</span> <span class="k">no</span> <span class="n">inbox_candidates</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Lastly, we just have to update the fact that forced valid events to occur to
consider the message parameters and the new predicates.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">message_events</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span>
    <span class="n">stutter</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">ElectedMsg</span> <span class="o">|</span> <span class="n">processElected</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span> <span class="ow">or</span>
    <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">CandidateMsg</span><span class="o">|</span> <span class="n">processCandidate</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-29">Let us validate the new version of our protocol using the functionalities
provided by the Analyzer. Let us run our empty <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> command <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">example</span></code> just to
explore some possible traces. The first trace returned is one where there is a
single node and the system stutters forever (recall that bounded model checking
guarantees minimal trace prefix length). By hitting <span class="guilabel">New Fork</span> we
should be able to observe a different event, namely an <em>initiate</em> event.
However, depending on the selected solver, we may get the following message.</p>
<a class="reference internal image-reference" href="../../_images/validation1.png"><img alt="../../_images/validation1.png" class="align-center" src="../../_images/validation1.png" style="width: 600px;" /></a>
<p>Let’s try to use the evaluator to debug the trace. Recall that the evaluator for
traces supports any formula and expression, and that this evaluation is always
performed on the focused state (the one at the left-hand side). We can start by
confirming that the system is simply stuttering by calling <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">stutter</span></code> at the
current state (in this case, the initial one since we did not navigate in the
trace), if it is happening <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">after</span></code> or even <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">always</span></code>. For all theses cases the
evaluator will answer <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">true</span></code> as expected. We can then ask the evaluator whether
there is <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">some</span></code> node for which the guard of the <em>initiate</em> predicate holds (a
formula with the past operator <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">historically</span></code>), or use comprehension to get all
nodes for which that guard holds. The evaluator will show us that it holds for
the existing node. It is worth reminding that evaluation over a specific
instance is very efficient, so it can be used abundantly. If the guard holds but
the event cannot happen, it means that the effects of the event cannot be
applied. By scope of the quantification searching for the new candidate message,
the issue becomes clear: there is no available <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> message in the
configuration of this trace that can be added to the successor’s inbox.</p>
<a class="reference internal image-reference" href="../../_images/validation2.png"><img alt="../../_images/validation2.png" class="align-center" src="../../_images/validation2.png" style="width: 600px;" /></a>
<p>This issue is actually evident if we inspect the available messages in the
visualizer, as there are only <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ElectedMsg</span></code> messages in the configuration. This
is a case where the guard does not necessarily entail the enabledness of the
event. So we can hit <span class="guilabel">New Config</span> until a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> is available
(after closing the evaluator). This should happen after a few iterations. Then,
we can ask again for <span class="guilabel">New Fork</span>, and this time a node will effectively
initiate.</p>
<a class="reference internal image-reference" href="../../_images/instance191.png"><img alt="../../_images/instance191.png" class="align-center" src="../../_images/instance191.png" style="width: 600px;" /></a>
<p>Let us continue to validate the protocol by inspecting a different network
configuration (recall that with up to 3 nodes, there are only 4 distinct
configurations). This should be easy to achieve by using <span class="guilabel">New Config</span>.
Unfortunately, you’ll notice that the network configuration stayed the same,
only the set of available messages changed. Since, as we’ve seen, the available
messages are also part of the configuration, for the selected solver we actually
need to hit <span class="guilabel">New Config</span> 10 times before seeing a different ring
network, and dozens of times to inspect the 4 alternatives, as the Analyzer will
just iterate over different sets of available messages.</p>
<a class="reference internal image-reference" href="../../_images/validation3.png"><img alt="../../_images/validation3.png" class="align-center" src="../../_images/validation3.png" style="width: 800px;" /></a>
<a class="reference internal image-reference" href="../../_images/validation4.png"><img alt="../../_images/validation4.png" class="align-center" src="../../_images/validation4.png" style="width: 800px;" /></a>
<a class="reference internal image-reference" href="../../_images/validation5.png"><img alt="../../_images/validation5.png" class="align-center" src="../../_images/validation5.png" style="width: 800px;" /></a>
<p id="index-30">One possible solution to circumvent these issues with message configurations is
to enforce a <em>generator axiom</em>. These are constraints that force every possible
combination of field values of a signature to exist in every instance. In our
leader election model, we would want to force the existence of messages with all
possible values, which would look like the following predicate.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">generator</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span>   <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In order for models with the generator axiom to be consistent, we must set the
scope to allow every possible unique message. In our model, we can have one
message of each type for each available node, so the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Message</span></code> scope should be
twice that of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span></code>. Notice that we define the generator axiom as a predicate,
rather than a fact: enforcing all possible messages to exist is helpful when
exploring scenarios, but not when checking properties, where enforcing such a
large set of messages would possibly encumber the solving process (satisfiable
commands, such as those generating scenarios, usually finish quickly). So we
call this predicate only in <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">run</span></code> commands for validation, such as the one
below for ring networks with exactly 3 nodes.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3_generator</span> <span class="o">{</span>
  <span class="n">generator</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<p>This command now guarantees there is a unique configuration of messages
available, and hitting <span class="guilabel">New Config</span> will effectively generate a new
network configuration. Unfortunately, this will only work if the scope for
messages is known exactly, which is not always easy to identify. Otherwise,
different messages with the same payload to be allowed to appear in the
configuration, giving rise again to the validation issues we were trying to
address. In fact, that will be the case if we no longer ask for <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">exactly</span></code> 3
nodes in the command above: for ring networks with 2 nodes, 6 messages result in
repetitions. To address this, we can also additionally enforce messages to be
unique with the following predicate.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">unique</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">m1</span><span class="p">,</span><span class="n">m2</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">m1</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">payload</span> <span class="ow">implies</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span>
  <span class="k">all</span> <span class="n">m1</span><span class="p">,</span><span class="n">m2</span> <span class="p">:</span> <span class="n">ElectedMsg</span>   <span class="o">|</span> <span class="n">m1</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">payload</span> <span class="ow">implies</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Given this, even if we assign a scope to messages larger than the one needed, a
unique message configuration is guaranteed to be generated.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3_unique_generator</span> <span class="o">{</span>
  <span class="n">generator</span>
  <span class="n">unique</span>
<span class="o">}</span> <span class="k">for</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="mi">10</span> <span class="n">Message</span>
</pre></div>
</div>
<p>However, by forcing messages to be unique, we are actually restricting the set
of possible behaviors of our protocol, and we must consider the implications of
that decision. The main consequence is that, since inboxes are modeled as sets,
it is now impossible to have two messages with the same content in an inbox
(elements are unique in sets). But this was already the case in the version of
the  model without messages - a node identifier could only appear once in an
inbox - so supporting duplicated messages is actually deviating from the
original model. Regardless, this shouldn’t be a problem since in our current
version each node generates at most one candidate message and an elected
message. In the next section we will see how to support repeated messages in
inboxes even if they are unique using sequences.</p>
<p>Regardless of the issues with trace iteration, we should always reason carefully
about message scopes. For instance, we could try ask for a scenario  where all
nodes initialize and eventually one of them is elected with the following
invalid command.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">bad_example</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">eventually</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span><span class="o">.</span><span class="n">inbox</span> <span class="o">&amp;</span> <span class="n">ElectedMsg</span>
<span class="o">}</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="mi">20</span> <span class="k">steps</span>
</pre></div>
</div>
<p>The Analyzer will reply that there is no such trace. That’s because the default
scope for signatures is 3, and 3 messages are not sufficient to represent this
trace (at least 4 are needed). This can also lead to a false sense of safety
from <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">check</span></code> commands, since a limited set of messages may reduce the valid
traces explored by the Analyzer.</p>
<p>So, before re-running the 3 check commands defined previously for our leader
election protocol, we should extend the scope of available messages (and also
adapt the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness</span></code> condition to the adapted guard of the <em>initiate</em> event).
They will all hold at this point.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../../_images/log1.png"><img alt="../../_images/log1.png" class="align-center" src="../../_images/log1.png" style="width: 600px;" /></a>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>actually, if we change the fairness condition to be the actual enabled
condition of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">initiate</span></code> - i.e., that there is a message available -
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_least_one_leader_fair</span></code> will no longer hold because the event will no be
enabled in configurations without messages and will not need to occur.</p>
</div>
</section>
<section id="messages-as-mutable-signatures">
<h3>Messages as mutable signatures<a class="headerlink" href="#messages-as-mutable-signatures" title="Link to this heading">#</a></h3>
<p>The issues met above when validating the model were caused by messages being
part of the trace configuration. So one might wonder whether it would be a
better approach to make <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Message</span></code> a mutable signature rather than a static one.
This way messages would not be part of the configuration and would be e created
– i.e., added to the mutable signature – as the system evolves. While this is
a feasible approach, it will also has an additional modeling – and performance
– overhead.</p>
<p>To make messages mutable, we just have to mark the relevant signatures as <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">var</span></code>.
This includes both the top-level signature and the specific sub-signatures,
since creating a message of a specific type also changes the value of the
top-level <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Message</span></code>. The fields must also be marked as mutable: if <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">payload</span></code> was
static, newly created messages could not have a payload assigned.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">payload</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>

<span class="k">var</span> <span class="kd">sig</span> <span class="nc">CandidateMsg</span><span class="p">,</span> <span class="nc">ElectedMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{}</span>
</pre></div>
</div>
<p>To keep the model simple, let us assume that messages can be created by events
but are not deleted, even after being processed. So, an event predicate either
creates a new message, or leaves the set of exiting messages unchanged. To
support this, let us create two auxiliary predicates, shown below.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">new_message</span> <span class="o">[</span><span class="n">m</span> <span class="p">:</span> <span class="n">Message</span><span class="p">,</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">Message</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Message</span> <span class="o">+</span> <span class="n">m</span>
  <span class="n">payload</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">n</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">same_messages</span> <span class="o">{</span>
  <span class="n">Message</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Message</span>
  <span class="n">payload</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">payload</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now, adapting the version of the predicates that considered static messages is
rather straightforward. Only two changes must be made: first, when searching for
a message to be created it must be selected from the <em>succeeding</em> state, since
it still doesn’t exist in the current state. Second, either <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">new_message</span></code> or
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">same_messages</span></code> must be called to manage the set of available messages. For
<em>initiate</em>, this would look as follows. Notice how the quantification now
searches for an appropriate message in the succeeding state using <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="o">&#39;</span></code>. The whole
expression must be primed since both the set of messages <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> and the
field <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">payload</span></code> must be evaluated in the succeeding state. Alternatively, one could
write <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span><span class="o">&#39;</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">&#39;.</span><span class="n">n</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>
  <span class="ow">historically</span> <span class="k">no</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// guard</span>
  <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="o">(</span><span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span><span class="o">)&#39;</span> <span class="o">{</span>
    <span class="n">new_message</span><span class="o">[</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">]</span>
    <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m</span>                     <span class="c1">// effect on n.succ.inbox</span>
    <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>           <span class="c1">// effect on the outboxes of other nodes</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The two <em>process</em> predicates are adapted in a similar manner. For instance, below is
the one for processing candidate messages, where the set of messages does not change
unless the nodes is elected and creates a new <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ElectedMsg</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processCandidate</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">processMessage</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">]</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">m</span><span class="o">.</span><span class="n">payload</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">same_messages</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m</span> <span class="c1">// effect on n.succ.inbox</span>
                  <span class="k">else</span>    <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span>
                      <span class="o">(</span><span class="k">some</span> <span class="n">m2</span> <span class="p">:</span> <span class="n">ElectedMsg</span><span class="o">&#39;</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">&#39;.</span><span class="n">n</span> <span class="o">|</span> <span class="n">new_message</span><span class="o">[</span><span class="n">m2</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">m2</span><span class="o">)</span>
                  <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">same_messages</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Other than this, except for enforcing the set of messages to be empty in the
initial state, no other changes need be made to the model. As can be seen in the
instance below for <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">eventually_elected</span></code>, messages are no longer part of the
trace configuration, and are dynamically created as the system evolves. As a
consequence, calls to <span class="guilabel">New Config</span> always generate an alternative
network configuration.</p>
<a class="reference internal image-reference" href="../../_images/instance20.png"><img alt="../../_images/instance20.png" class="align-center" src="../../_images/instance20.png" style="width: 600px;" /></a>
<p>The <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">check</span></code> commands can also be run exactly as they are, and will show to hold.
However, you will notice that this idiom has a considerable toll on performance
compared to the one where messages are static. For instance, the same
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_most_one_leader</span></code> command whose execution log was shown above now takes an
order of magnitude longer to finish.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../../_images/log2.png"><img alt="../../_images/log2.png" class="align-center" src="../../_images/log2.png" style="width: 600px;" /></a>
<p>Having mutable messages, however, can allow for richer traces with smaller
message scopes since messages can be reused with different contents over the
trace. For instance, in our model, if we deleted messages after being processed,
we could reuse the same candidate message with different identifiers at
different points of the trace. Recall, however, that scopes can only be assigned
to top-level mutable signatures, and that atoms may not change the sub-signature
they belong to along the trace (i.e., a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">CandidateMsg</span></code> atom cannot become an
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">ElectedMsg</span></code> one).</p>
</section>
<section id="messages-as-tuples">
<h3>Messages as tuples<a class="headerlink" href="#messages-as-tuples" title="Link to this heading">#</a></h3>
<p>The two strategies we’ve seen above modelled messages as signatures, which is
perhaps a way to reason about design that is close to the implementation level.
However, we can also explore Alloy’s flexible relational logic to implement a
more abstract version that bypasses signatures and implements messages directly
as tuples. This has the advantage of avoiding the validation issues depicted
above, and having a reduced performance overhead. The tradeoff is that it doesn’t
scale very well for more complex message types.</p>
<p>Recall that fields in Alloy can be of arbitrary arity, so one can simply define
inboxes as a set of tuples relating all fields of a message: if a message has 2
fields of type <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">A</span></code> and <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">B</span></code>, then the inbox will contain pairs <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>. However,
we will also need to identify the type of the message in the inbox. So the inbox
will actually contain triples <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>. Since each inbox is associated
to a node, this would result in a quaternary <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">inbox</span></code> relation with type <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span> <span class="o">-&gt;</span>
<span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>. This would work if all message types contain exactly the same
mandatory fields of the same type, otherwise we would need to somehow normalize
this tuple set (more on this later).</p>
<p>In our current example we have two kinds of messages that happen to have the
same single, mandatory field containing a node identifier, so it can simply be
encoded as the following mutable ternary relation.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Type</span> <span class="o">{}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Candidate</span><span class="p">,</span> <span class="nc">Elect</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{}</span>

<span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span>      <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span>      <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Id</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Notice that this idiom again disallows repeated messages in the inboxes, since a
tuple <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Id</span></code> can only appear once in the inbox. But this was already the
case in our initial version of the protocol before messages as signatures were
introduced.</p>
<p>Adapting the event predicates is actually simpler than the version with messages
as signatures, since we can always create a new tuple with the needed atoms,
while the messages-as-signatures version required the existence of an adequate
message. So, in the <em>initiate</em> event, the guard just has to check whether the
tuple <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">n</span></code> has ever been in the inbox of the successor, and if
not that ‘message’ is added to the successor’s inbox.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>
  <span class="ow">historically</span> <span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// guard</span>
  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">n</span>   <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">n2</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <em>process</em> events are also trivially adapted from the version without
messages by just considering the appropriate type in the inbox. The
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">processMessage</span></code> auxiliary predicate now must take the type of the message as an
additional parameter <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">t</span></code>, and then just tests whether the tuple <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i</span></code> -
representing the message of type <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">t</span></code> with content <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">i</span></code> - is in the inbox of the
processing node <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code>. If so, it is removed from the inbox, and all nodes preserve
their inbox, except for the processing node and its successor.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processMessage</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">t</span> <span class="p">:</span> <span class="n">Type</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                 <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i</span>                       <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">n2</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The effect of the <em>process</em> events is just adapted to create message tuples of
the appropriate type.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processCandidate</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">processMessage</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">Candidate</span><span class="o">]</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="c1">// effect on n.succ.inbox</span>
          <span class="k">else</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">Elect</span> <span class="o">-&gt;</span> <span class="n">n</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">processElected</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">processMessage</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">Elect</span><span class="o">]</span>

  <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">Elect</span> <span class="o">-&gt;</span> <span class="n">i</span>      <span class="c1">// effect on n.succ.inbox</span>
         <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>

<span class="o">}</span>
</pre></div>
</div>
<p>And the same applies to the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Elected</span></code> function, that must identify candidate
messages in the inbox.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">and</span> <span class="n">Candidate</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>At this point, all commands will show to hold for this version of the model.
Below is a transition for the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">eventually_elected</span></code> command.</p>
<a class="reference internal image-reference" href="../../_images/instance211.png"><img alt="../../_images/instance211.png" class="align-center" src="../../_images/instance211.png" style="width: 600px;" /></a>
<p>Notice that, without messages as signatures, messages are now represented as
edges in the visualizer. In this case, the inbox is a ternary relation <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span> <span class="o">-&gt;</span>
<span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Node</span></code>, so the type appears as an annotation of the edge. This may be
arguably more difficult to interpret than the previous version.</p>
<p>It is also worth noting that the analysis of this version of the model is much
more efficient than the ones with explicit messages. Running the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_most_one_leader</span></code> command, whose log was already shown for the other
versions, is now one order of magnitude faster than the version with static
messages.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">3</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../../_images/log3.png"><img alt="../../_images/log3.png" class="align-center" src="../../_images/log3.png" style="width: 600px;" /></a>
</section>
<section id="handling-richer-message-types">
<h3>Handling richer message types<a class="headerlink" href="#handling-richer-message-types" title="Link to this heading">#</a></h3>
<p>The shape of the messages that we’ve considered for the leader election protocol
are actually quite simple, with two message types that happen to contain the
same single, mandatory field.</p>
<p>Let us consider an additional, optional field <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">r</span></code> with type <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">X</span></code>, in elected
messages.</p>
<p>With messages as signatures, this is easy to encode: just add a new <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">lone</span></code> field
to the respective message type.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="n">payload</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>

<span class="kd">sig</span> <span class="nc">CandidateMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{}</span>
<span class="kd">sig</span> <span class="nc">ElectedMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="n">r</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">X</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Adapting the events is mostly straightforward, just determining the correct
value of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">r</span></code>. However, issues with scope are now exacerbated: there is now
need to <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">n</span></code> messages to represent all possible message values (the generator
axiom must be adapted to also force cases where <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">r</span></code> is empty).</p>
<p>In the messages as tuples idiom, we must now normalize the inbox type. Elected
messages with <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">r</span></code> will now be represented by a quaternary tuple <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">Type</span> <span class="o">-&gt;</span>
<span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">X</span></code>. But all tuples in a relation must have the same arity, so we must
normalize it to consider both candidate ternary messages and elected messages
without the optional field. Thus, we introduce an <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Empty</span></code> singleton signature to
pad the tuples: it will always be the forth element of candidate messages, and
possibly the one of elected messages.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Type</span> <span class="o">{}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Candidate</span><span class="p">,</span> <span class="nc">Elect</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{}</span>

<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Empty</span> <span class="o">{}</span>

<span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span>      <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span>      <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span> <span class="p">:</span> <span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Id</span> <span class="o">-&gt;</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Empty</span>
<span class="o">}</span>
</pre></div>
</div>
<p>One may wonder whether any of these idioms would be able to support higher-arity
message fields. In principle, it could be possible to do when modelling messages
as signatures by just having a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">set</span></code> field. However, it wouldn’t be possible to
enforce the generator axiom to address the validation issues since it would
require higher-order quantifications. The messages as tuples idiom simply could
not support this kind of messages.</p>
</section>
</section>
<section id="richer-message-passing-models">
<h2>Richer message-passing models<a class="headerlink" href="#richer-message-passing-models" title="Link to this heading">#</a></h2>
<p>So far we’ve assumed that the order that the messages reach an inbox - and
possible repeated messages - was irrelevant. That is the case for the current
version of the leader election protocol because nodes only initiate once, and
thus only generate a single message with their identifier. However, if we wanted
analyse whether our protocol was robust to failures in the communication
channels, we should allow nodes to occasionally re-initiate if they did not
receive an acknowledgement from the successor node. This will however be
problematic in our current model and invalidate the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_least_one_leader</span></code>
liveness property.</p>
<p>Let us recover the version of the protocol without explicit messages, and start
by relaxing the guard of the <em>initiate</em> event, so that it can initiate whenever
its own identifier is not currently in the inbox of the successor by removing
the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="ow">historically</span></code> operator (and adapt the respective <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness</span></code> condition).</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>
  <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>                       <span class="c1">// guard</span>
  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span>            <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>  <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">fairness</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="ow">eventually</span> <span class="ow">always</span> <span class="o">(</span><span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span>
    <span class="ow">implies</span>
    <span class="ow">always</span> <span class="ow">eventually</span> <span class="o">(</span><span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">|</span> <span class="n">process</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>All safety commands are still valid under this version, but the
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_most_one_leader</span></code> becomes invalid, as perhaps was expected. The first
counter-example returned is the following.</p>
<a class="reference internal image-reference" href="../../_images/instance221.png"><img alt="../../_images/instance221.png" class="align-center" src="../../_images/instance221.png" style="width: 600px;" /></a>
<p>This trace alternates between one node initiating, and the other processing the
received message. Why doesn’t the fairness condition guarantee that every node
eventually initiates? By inspecting the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness</span></code> predicate you’ll see that we
are only forcing every node to eventually perform an event if any event is
permanently enabled. That is true in this trace: the non-initiating node keeps
processing the other’s message every two states. So this notion of
‘process-wise’ fairness is too coarse to force every permanently enabled event
to occur. For that, we would need a ‘event-wise’ notion of fairness, which could
be written as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">fairness_event</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="o">(</span><span class="ow">eventually</span> <span class="ow">always</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="ow">implies</span> <span class="o">(</span><span class="ow">always</span> <span class="ow">eventually</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
    <span class="o">(</span><span class="ow">eventually</span> <span class="ow">always</span> <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="ow">implies</span> <span class="o">(</span><span class="ow">always</span> <span class="ow">eventually</span> <span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">|</span> <span class="n">process</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now, if <em>initiate</em> is permanently enabled for a given node, it must be executed,
and likewise for <em>process</em>. This will fix the issue evidenced by the
counter-example above, but still not make <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_least_one_leader</span></code> valid. Below is
a transition of a counter-example trace now returned.</p>
<a class="reference internal image-reference" href="../../_images/instance231.png"><img alt="../../_images/instance231.png" class="align-center" src="../../_images/instance231.png" style="width: 600px;" /></a>
<p>Essentially, the trace enters a loop where the potential leader node has two
messages in the inbox - one with its own identifier and another with the
identifier of its successor - but always processes the one belonging to the
other node, thus never being elected the leader. The node is effectively
processing messages as imposed by our new notion of fairness - just not the one
it should.</p>
<p>There are two possibilities to handle this issue. One is to enforce an even
finer notion of fairness, forcing every possible event input to be eventually
processed. This notion of ‘point-wise’ fairness could be written as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">fairness_pointwise</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="o">(</span><span class="ow">eventually</span> <span class="ow">always</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="ow">implies</span> <span class="o">(</span><span class="ow">always</span> <span class="ow">eventually</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
    <span class="o">(</span><span class="ow">eventually</span> <span class="ow">always</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="ow">implies</span> <span class="o">(</span><span class="ow">always</span> <span class="ow">eventually</span> <span class="n">process</span><span class="o">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>With this fairness constraint, <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">at_least_one_leader</span></code> will become valid. However,
bear in mind that stronger notions of fairness make acceptable traces
considerably longer, and thus require larger <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">steps</span></code> scopes to guarantee that
relevant traces are explored. In fact, while the smallest trace under
‘process-wise’ <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness</span></code> has 3 states, the one under ‘event-wise’
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness_event</span></code> has 6, and the one under ‘point-wise’ <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">fairness_pointwise</span></code> 8.
One may also wonder whether such a strong fairness constraint is reasonable to
enforce: can we really guarantee that every message will be processed in a
realistic system?</p>
<p>An alternative, and perhaps more realistic, approach is to instead guarantee
that messages are processed in the order they are received, and thus
guaranteeing cannot permanently put new messages in front of existing ones. This
can be achieved by modelling inboxes as a <em>sequence</em> of messages rather then a
set, i.e., modelling the inboxes as queues. As a side-effect, this will also
allow for repeated messages to appear in the inbox.</p>
<p>Sequences in Alloy are introduced with the keyword <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">seq</span></code>, and are essentially a
binary relation between integer indices to elements of the specified type.  The
scope of indices is bounded, meaning that sequences cannot grow indefinitely.
Changing our inboxes to sequences results in the following signature
declaration.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span>       <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">id</span>         <span class="p">:</span> <span class="k">one</span> <span class="n">Id</span><span class="p">,</span>
  <span class="k">var</span> <span class="n">inbox</span>  <span class="p">:</span> <span class="k">seq</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To adapt the events, we can make use of the auxiliary functions provided by
utility module <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">sequniv</span></code> whenever sequences are used. For instance, to test
whether a message is already in the inbox of the successor in the guard of the
<em>initiate</em> event, one can use <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">elems</span></code> to get all elements in a sequence. To add
a new message to an inbox, one can use function <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">add</span></code> to add an element to the
end of a sequence. If the sequence is already full, the new element is
discarded.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>
  <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elems</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                <span class="c1">// guard</span>
  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">add</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span><span class="n">n</span><span class="o">]</span>         <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>  <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <em>process</em> event can be adapted in a similar manner. Rather than selecting an
arbitrary message from the inbox, it now must select the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">first</span></code> element in the
sequence, and then it is updated by keeping only the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">rest</span></code> of the sequence.
When propagating the message, is it also added to the successor’s inbox with
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">add</span></code>.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>
  <span class="n">i</span> <span class="ow">in</span> <span class="n">first</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                              <span class="c1">// guard</span>
  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">rest</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                         <span class="c1">// effect on n.inbox</span>
  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">add</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span><span class="n">i</span><span class="o">]</span> <span class="c1">// effect on n.succ.inbox</span>
          <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, we must adapt the notion of elected. It is not sufficient to say that a
node is elected when its identifier is in the first position of the inbox in a
state and not in the succeeding one: if a node has multiple copies of its own
identifier in the inbox, it can process the first one and in the succeeding
state still have its own identifier in the first position of the inbox, just
another copy. A possibility is to say that the node’s own identifier has less
occurrences in the inbox’s next state. This can be achieved using function
<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">indsOf</span></code> as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="o">(</span><span class="k">some</span> <span class="n">indsOf</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span><span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="o">(</span><span class="n">indsOf</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span><span class="n">n</span><span class="o">])&#39;))</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>At this point our leader election model with queues can be validated, and the
safety properties will be valid. However, yet another novel issue will occur
when checking the liveness property. Below is a transition of a counter-example
with 10 states that highlights the new issues with out model.</p>
<a class="reference internal image-reference" href="../../_images/instance241.png"><img alt="../../_images/instance241.png" class="align-center" src="../../_images/instance241.png" style="width: 600px;" /></a>
<p>Here, the potential leader (<code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code>) has 3 messages in the inbox, pointing to
two other nodes. <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node2</span></code>, its predecessor, has actually a <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code> message ready
to send to <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code>, which would allow it to be elected as leader. However, that
message is actually lost when <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code> processes it. The problem here has to do
with the scope on sequences: sequences in Alloy are always bounded, with a
maximum size of 3 by default. Since the inbox of <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">Node1</span></code> is full, it never
receives its own identifier. You could try to increase the scope on <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="k">seq</span></code> to
support larger inboxes, but this is just postponing the issues: with <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="mi">4</span> <span class="k">seq</span></code> a
similar counter-example is now found with 13 states.</p>
<p>So it seems that the liveness property of our leader election protocol does not
hold when messages are discarded from the inboxes. So in practice, nodes must
guarantee that the the successor node is able to receive the message. At the
level abstraction that we are working, this can be simulated by adding a new
guard to  events that tests whether the successor’s inbox is full. We can use
the <code class="code highlight alloy electrum docutils literal highlight-electrum"><span class="n">afterLastIdx</span></code> function for this purpose, that returns empty when there are
no indices left to use in a sequence. The <em>initiate</em> event would look as follows.</p>
<div class="highlight-electrum notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>
  <span class="k">some</span> <span class="n">afterLastIdx</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>             <span class="c1">// guard on n.succ.inbox</span>
  <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elems</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                <span class="c1">// guard on n.inbox</span>
  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">add</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span><span class="n">n</span><span class="o">]</span>         <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>  <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, our liveness property is now valid for the version of the protocol with
queues.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../app-design/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">App design</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../behavioral-topics/topics/meta/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Meta-capabilities</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021-2024, Alcino Cunha, Nuno Macedo, Julien Brunel, David Chemouil
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Protocol design</a><ul>
<li><a class="reference internal" href="#specifying-the-network-configuration">Specifying the network configuration</a></li>
<li><a class="reference internal" href="#specifying-the-protocol-dynamics">Specifying the protocol dynamics</a></li>
<li><a class="reference internal" href="#verifying-the-expected-properties-of-the-protocol">Verifying the expected properties of the protocol</a></li>
<li><a class="reference internal" href="#making-the-specification-more-abstract">Making the specification more abstract</a></li>
<li><a class="reference internal" href="#explicit-message-passing">Explicit message-passing</a><ul>
<li><a class="reference internal" href="#messages-as-static-signatures">Messages as static signatures</a></li>
<li><a class="reference internal" href="#messages-as-mutable-signatures">Messages as mutable signatures</a></li>
<li><a class="reference internal" href="#messages-as-tuples">Messages as tuples</a></li>
<li><a class="reference internal" href="#handling-richer-message-types">Handling richer message types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#richer-message-passing-models">Richer message-passing models</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=10f1778b"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    </body>
</html>