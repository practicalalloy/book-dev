.. todo::

  Missing: lexical scoping, example of partial application


.. _macros: 

Macros
----------------------------------------

The Alloy Analyzer comes with a textual macro system that can be handy to define reusable expressions or constraints with less technical restrictions than functions or predicates, but less safeguard too.

Textual macros
===================

A predicate or function provides the ability to define a reusable expression or constraint, possibly with formal parameters. A predicate or function definition must comply with certain technical requirements, which are checked by the Alloy Analyzer:

* The possible formal arguments can only stand for expressions (not predicates);
* The actual arguments must comply with the type and arity declared for formal parameters.

Macros are also reusable expressions or constraints. Syntactically, a macro is defined at the top level of a file, using the `let` keyword, like a `pred` or `fun`: 

.. code::
  
  let m [x, y, ...] { ... }

But the definition, on the other hand, is less constrained: 

* The type and arity of formal arguments is not checked;
* The arguments can not only stand for expressions or constraints, but even for partially-applied functions, predicates or macros.

Then, calling a macro and passing it an actual parameter corresponds to substituting textually the bound variable with the said parameter. This process is classically called *macro expansion* in programming languages. This is very powerful but the consequence is that most typing or arity errors, made when calling a macro, may be cryptic, and the originating error may be difficult to spot.

For this reason, the use of macros is rather discouraged. Nevertheless their flexibility can be useful to write shorter and clearer specifications, so we illustrate them on two examples:

* The first one shows hows the absence of arity checking can be leveraged to simplify the writing of frame conditions;
* The second one shows how one can define constraint *schemas* thanks formal parameters standing for constraints.


A macro for frame conditions
==============================

In :ref:`pointwise-effects`, we saw two equivalent ways to specify action `share`:

.. code::

  // relational style
  pred share [f : File, t : Token] {
    f in uploaded - trashed             // guard
    historically t not in File.shared   // guard
    shared' = shared + f->t             // effect on shared
    uploaded' = uploaded                // no effect on uploaded
    trashed' = trashed                  // no effect on trashed
  }

  // pointwise style
  pred share [f : File, t : Token] {
    f in uploaded - trashed                  // guard
    historically t not in File.shared        // guard
    f.shared' = f.shared + t                 // effect on f.shared
    all g : File - f | g.shared' = g.shared  // no effect on other shared files
    uploaded' = uploaded                     // no effect on uploaded
    trashed' = trashed                       // no effect on trashed
  }

In both approaches, specifying *frame conditions* (constraints stating that some mutable signature or field doesn't change under the action) is tedious and error-prone. Now suppose we had an `unchanged` predicate ensuring some argument doesn't change in the next instant. With such a predicate, our specification of frame conditions would be shorter and safer:

.. code::

  // relational style
  pred share [f : File, t : Token] {
    f in uploaded - trashed             // guard
    historically t not in File.shared   // guard
    shared' = shared + f->t             // effect on shared
    unchanged[uploaded]                 // no effect on uploaded
    unchanged[trashed]                  // no effect on trashed
  }

  // pointwise style
  pred share [f : File, t : Token] {
    f in uploaded - trashed                  // guard
    historically t not in File.shared        // guard
    f.shared' = f.shared + t                 // effect on f.shared
    all g : File - f | unchanged[g.shared]   // no effect on other shared files
    unchanged[uploaded]                      // no effect on uploaded
    unchanged[trashed]                       // no effect on trashed
  }

In the example above, `unchanged` is applied to sets but, for full generality, it should also be possible to apply it to a relation, such as `shared` in action `upload`:

.. code::

  // relational style
  pred upload [f : File] {
    f not in uploaded          // guard
    uploaded' = uploaded + f   // effect on uploaded
    unchanged[trashed]         // no effect on trashed
    unchanged[shared]          // no effect on shared
  }

Defining such a generic predicate is however impossible. Indeed, in Alloy, predicate (or function) arguments must have a single, fixed arity, while `unchanged` should accept any positive arity. 

It is possible to define `unchanged` as a *macro* as macros do not check the type nor arity of arguments, which is precisely the feature we need: 

.. code::

  let unchanged[x] { x = (x)' }

Notice parentheses in `(x)'` are *absolutely required*: when calling `unchanged`, the actual argument coming in place of `x` may be an arbitrary complex expression, like in `unchanged[g.shared]` in action `share`. Suppose the expression has the shape `r.s.t`, with `r` and `t` both *mutable* fields, while `s` is static. Then our definition of `unchanged` will ensure that the prime operator is properly applied to every mutable sub-term. Indeed, according to the semantics of the prime operator, `(r.s.t)'` is equal to `r'.s'.t'`, which is equal to `r'.s.t'` as `s` is static.


Defining a constraint schema using a macro
============================================

In :ref:`behavioral-modeling`, checking the `non_restored_files_will_disappear` assertion (a *liveness* property) relied on a *fairness* assumption specified as:

.. code::

  fact fairness_on_empty {
    always (
      always some trashed implies
      eventually empty
    )
  }

While it was not the case here, often, several events must enjoy such a fairness assumption in order to ensure a liveness property. The only difference between all these assumptions is the enabling condition (here `some trashed`) and the predicate representing the fired event (here `empty`). We could just repeat them several times but it's admittedly cumbersome and even error-prone. 

A better solution would be to create a constraint parameterized by two formal arguments. This is precisely the second possibility offered by the macro system. We can thus define a `fair` macro as follows:

.. code::

  let fair [ena, ev] { always (always (ena) implies eventually ev) }

  fact fairness_on_empty { fair[(some trashed), empty] }

Notice we write `ena` between parentheses in case the actual parameter contains logical connectives of lower precedence than `implies` (such as `or`). Without parentheses, `fair[a or b, e]` would expand to `always (always a or b implies eventually e)`, which is equivalent to `always ((always a) or (b implies eventually e))`, not what we expect! 


