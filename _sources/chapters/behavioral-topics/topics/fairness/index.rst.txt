.. _fairness:

Safety, Liveness and Fairness
========================

.. todo:: 
  @julien and @david: also talk about liveness properties, frame conditions




Safety vs liveness properties
-----------------

A distinction between safety and liveness properties is often adopted when it comes to temporal properties. These notions are introduced by Lamport [TSE77]_. Roughly speaking, a safety property states that *something bad will not happen* and a liveness property states that *something good will happen*.

Invariant: particular case

.. note:: Proving invariant
	  In the context of deductive methods, ....


Liveness properties
-----------------

Context: model specified through events. We want to talk about fairness. This requires to reason about enabledness of events. In general, enabledness is not the same as guards. Global temporal facts may interfere and make guards distinct from enabled.
What is a guard?
A guard is a present or past formula and is a (the strongest ?) necessary condition  of the event to happen. It is a syntactically criterion, so it needs a syntactic definition of what an event is to be defined.

Ways to differ between guards and enabled: 

An event is not enabled while its guard is true in the following cases:

- its effect violates a fact (explicit fact or typing/mutiplicity contraint)
- it is not be enabled because of the bound on steps

In the following restricted context, guard and enabled are equivalent:

- no temporal fact (even mutliplicity contraints, typing contraints could reamain thanks to Alloy typing system) except "always some event"
- facts about static relations and facts only reasoning about the initial state are allowed
- each event is syntactically limited :

  + guard is a formula of present and past
  + the only future state that can be constrained is the immediate successor of the current state
- the "prevent overflow" option is uncrossed 



Fairness conditions
----------------------------------------

.. _enabled:

When is an event enabled?

Instead of a predicate we could have specified the fairness
conditions inside a :code:`fact`, to force them to be true in all
analyses. However, in general that is not a good idea, since
:code:`run` commands would then only return fair traces, which
hinders the interactive exploration of scenarios and requires
much larger bounds on the number of steps (making the analysis
slower). For example, command

.. code-block::

    run {} for exactly 3 Node, exactly 3 Id

that asks for any trace in a ring with 3 nodes will not even return
a trace with the default scope of 10 :code:`steps`, because no fair
trace with this size exists for this configuration. The minimum
scope would be 14 :code:`steps`!

This also means that a command like :code:`check AtMostOneLeader`,
to verify the safety property of the protocol, would be mostly
pointless, as with the default scope of 10 :code:`steps` only
configurations with up to 2 nodes would be checked for
correctness. Without fairness imposed in a fact, it would at least
check that the safety property is not violated in the first 10
steps of any trace of the protocol, including unfair and fair
ones. Recall that in a counter-example of a safety property it is
irrelevant what happens after we reach a faulty state: any
continuation of the "bad" trace prefix would still be a
counter-example, including any fair continuation.
