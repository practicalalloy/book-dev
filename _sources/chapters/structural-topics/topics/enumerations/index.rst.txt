.. _enumerations:

Enumeration signatures
=======================

Models often require enumerated types that are fixed to contain certain atoms.
For example, let's build on the file system example from the main chapter
:ref:`structural-modeling`, and extend it with Unix-like file permissions, where
the file's owner, file's group and every other user are assigned either read,
write or execute permission. 


Declaring enumeration signatures
--------------------------------

.. index::
   ! signature; enumeration
   signature; singleton

In Alloy it is very common to use extension signatures of multiplicity
:alloy:`one` in the declaration of signatures that behave like enumerated data
types.  The following specification declares a :alloy:`Permission` signature that
contains exactly three permissions: :alloy:`Read`, :alloy:`Write`, and
:alloy:`Execute`.

.. code-block::

    abstract sig Permission {}
    one sig Read, Write, Execute extends Permission {}

Here we see another feature of the Alloy language: if two or more
signatures share the same features (multiplicity, parent signature, fields, 
etc.) they can all be defined together in the same declaration with names separated by commas. This also applies to field and variable declarations.

This pattern for declaring signatures that essentially correspond
to enumerated data types is so common, that Alloy has a keyword
:alloy:`enum` for that purpose. Using this keyword, the
:alloy:`Permission` signature could be declared as follows.

.. code-block::

    enum Permission { Read, Write, Execute }

Using enumeration signatures
----------------------------

Enumeration signatures can be used as any other regular signature. In our example, we want each object in the file system to have a permission assigned to each group, so signature :alloy:`Object` could be extended as follows.

.. code-block::

    abstract sig Object {
        user_permission : set Permission,
        group_permission : set Permission,
        others_permission : set Permission
    }

Here, each of the 3 fields determines the permissions assigned to a scope. Running an empty :alloy:`example` command yields instances such as the following, after some theme customization (including hiding the enumeration and setting the permission fields point to be shown attributes).

.. image:: instance1.png
   :width: 500 px
   :align: center

An alternative encoding
-----------------------

While this models the desirable information, it is perhaps not the easiest encoding to maintain. An alternative is to also encode the different classes
as an enumeration signature, and then create a new signature that acts as a "record" that combines classes and permissions. This could be encoded as follows.

.. code-block::

    enum Class { User, Group, Other }

    sig PermissionAssignment {
        permission : set Permission,
        class : one Class
    }

    abstract sig Object {
        mode : set PermissionAssignment
    }

However, this no longer guarantees that for each object, there is exactly one permission assigned to each group. This requires the following additional fact.

.. code-block::

    fact all_classes_assigned {
        all o : Object, c : Class | one o.mode & class.c
    }

Unfortunately, this encoding also has a limitation: the number of distinct assignments of permissions to classes is determined by the scope on signature :alloy:`PermissionAssignment`. Since there are 3 different classes, this already uses up the complete default scope for :alloy:`PermissionAssignment`, and commands like the following yield no instance.

.. code-block::

   run distinct_permissions { some disj o1,o2 : Object | o1.mode != o2.mode }

If we increase, for instance, the overall scope to 4, the command will be able
generate instances such as the following (again, after some similar theme
customizations).

.. image:: instance2.png
   :width: 500 px
   :align: center

Yet another alternative encoding that would address both the maintainability and
scope issues could be defined by using *ternary* relations. These are addressed
in a dedicated chapter.

There is just a subtle difference between declaring enumeration signatures with
keyword :alloy:`enum` and with the normal :alloy:`sig` keyword with multiplicity
:alloy:`one`: the former additionally imposes a *total order* between the
respective atoms, corresponding to the order in which they are declared inside
the braces. Total orders in Alloy are explored in a different chapter.

.. card-carousel:: 2

   .. card:: The predefined :alloy:`ordering` module
      :link-type: ref
      :link: ordering

      :octicon:`link` Further reading
      ^^^
      Learn what are the consequences of having a total order imposed on enumeration signatures.  

   .. card:: Relations of higher arity
      :link-type: ref
      :link: nary-relations

      :octicon:`link` Further reading
      ^^^
      Learn about fields of higher-arity to simplify the representation of the permission fields.

   .. card:: Visualization customization
      :link-type: ref
      :link: theme-customization

      :octicon:`link` Further reading
      ^^^
      Throughout the chapter we've customized the visualization of instances. Learn in more detail how this can ease instance interpretation.

